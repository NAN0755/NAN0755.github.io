<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F01%2F12%2FTowards%203D%20Object%20Recognidtion%20via%20Classification%20of%20Arbitrary%20Object%20Tracks%2F</url>
    <content type="text"><![CDATA[Towards 3D Object Recognidtion via Classification of Arbitrary Object Tracks(斯坦福人工智能实验室 论文) ###Introduction障碍物识别包含：分割、追踪、分类等方面，并且对新的障碍物也能有效识别。 ###Related work当前障碍物识别基本分为两大领域：1.静止环境下的多级障碍物识别，一条路径中的障碍物识别。2.通过训练后的特定种类的障碍物识别跟踪。 过分割：一个物体被分割为两个物体，这种情况在点云中很常见，不应该被视为错误，而应该进行进一步处理。 ###The Stanford Track Collection介绍了该点云数据集的应用。 ####Details使用线性卡尔曼滤波来计算聚类的中心点。数据关联问题由测量中心到期望位置点解决。 ###Classification Methods ####Boosting FrameworkBoosting Framework: 将weak classification组合成一个简单的高精度的分类器。本论文使用两个了boosting classifiers，1）sgement classifier:预测一组分割描述对象，也就是一组描述障碍物的外观的向量某个时间中的;2)holistic classifier:预测一组跟踪的全局描述对象，也就是描述速度，加速度和其他跟踪信息的向量。 （后面看不懂了～）]]></content>
  </entry>
  <entry>
    <title><![CDATA[杭电ACM 1002]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%9D%AD%E7%94%B5ACM1002%2F</url>
    <content type="text"><![CDATA[去年6月份就弄好博客了，懒癌发作一直没弄，到10月份又开始弄硕士毕业论文，更没有时间，所以，一直到现在才开始搞。因为工作转行的关系，加上一直想上计算机科班出身的教程，所以自己没事瞎弄写相关的最基础的数据结构类代码。 好了废话不多说，开始进入正题。这是我撸的杭电ACM1002，下面把自己思路写下来。下面是刚拿到题时，没经过深思熟虑就写下了。 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(int argc, char *argv[]) { int caseNum; scanf(&quot;%d&quot;, &amp;caseNum); long long A, B; A = 0; B = 0; vector&lt;vector&lt;long long&gt;&gt; lineNum; lineNum.resize(caseNum); for (int i = 0; i &lt; caseNum; i++ ) { lineNum[i].resize(2); scanf(&quot;%lld%lld&quot;, &amp;A, &amp;B); lineNum[i][0] = A; lineNum[i][1] = B; } for (int i = 0; i &lt; caseNum-1; i++) { cout &lt;&lt; &quot;Case &quot; &lt;&lt; i+1 &lt;&lt;&quot;:\n&quot;; cout &lt;&lt; lineNum[i][0] &lt;&lt; &quot; + &quot; &lt;&lt; lineNum[i][1] &lt;&lt; &quot; = &quot; &lt;&lt;lineNum[i][0]+lineNum[i][1] &lt;&lt; &quot;\n&quot; &lt;&lt;endl; } cout &lt;&lt; &quot;Case &quot; &lt;&lt; caseNum &lt;&lt;&quot;:\n&quot;; cout &lt;&lt; lineNum[caseNum-1][0] &lt;&lt; &quot; + &quot; &lt;&lt; lineNum[caseNum-1][1] &lt;&lt; &quot; = &quot;&lt;&lt; lineNum[caseNum-1][0]+lineNum[caseNum-1][1] &lt;&lt;endl; return 0; } 根据题意，此处没考虑到： Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000 虽说，考虑到数有可能很大，使用了long long类型，但是数的位数有可能超过1000，所以没有一个现有的数据类型可以直接供加法运算。因此，对于很大位数的加法运算，需自己进行设计。​]]></content>
      <tags>
        <tag>HD ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开篇2017]]></title>
    <url>%2F2017%2F06%2F26%2F%E5%BC%80%E7%AF%872017%2F</url>
    <content type="text"><![CDATA[欢迎来到曾泽宇的个人博客，此博客将用作记录自己的一些技术上的问题和解决方法，借助这一个平台，希望给自己一个记录，让自己多年以后回过头来看看自己也曾经少年过，哈哈！]]></content>
      <tags>
        <tag>MarkDown Writting</tag>
        <tag>Personal</tag>
      </tags>
  </entry>
</search>